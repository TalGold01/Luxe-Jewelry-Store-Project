name: CI/CD Pipeline - Luxe Jewelry Store

# 1. Trigger the workflow on pushes to the main branch OR a new tag
on:
  push:
    branches:
      - main
    tags:
      - 'v*' # Trigger on any tag starting with 'v' (e.g., v1.0.0)

# Define global environment variables
env:
  DOCKERHUB_REGISTRY: talgold01
  NEXUS_REGISTRY: localhost:8082/docker-hosted
  PROJECT_NAME: luxe-jewelry-store-project 
  DEPLOY_ENV: development
  
  # VERSION CONTROL LOGIC
  IMAGE_VERSION: ${{ startsWith(github.ref, 'refs/tags/') && github.ref_name || github.run_id }} 

jobs:
  
  # ====================================================================
  # NEW JOB 1: PRE-BUILD SECURITY SCAN (Shift-Left)
  # This job must pass before the build and deploy pipeline starts.
  # ====================================================================
  security_scan_pre_build:
    runs-on: ubuntu-latest
    
    steps:
      - name: ‚¨áÔ∏è Checkout Repository
        uses: actions/checkout@v4
      
      # üîë Set up Snyk Token
      - name: üîë Set up Snyk
        uses: snyk/actions/setup@master
        with:
          # Ensure you have SNYK_TOKEN defined as a GitHub secret!
          snyk-token: ${{ secrets.SNYK_TOKEN }}

      - name: üõ°Ô∏è Snyk Code Scan (Source Code)
        # Scan the entire project source code for vulnerabilities (if applicable)
        # Note: This requires Snyk Code to be enabled for your token/account
        uses: snyk/actions/code@master
        
      - name: üêç Snyk Open Source Scan (Backend Dependencies)
        # Scan the requirements.txt or equivalent file for Python vulnerabilities
        # Assumes your main requirements file is in the 'backend' folder
        uses: snyk/actions/maven@master # Using a generic action for file scanning
        with:
          command: test
          args: --file=backend/requirements.txt --severity=high

      - name: üåê Snyk Open Source Scan (Frontend Dependencies)
        # Scan the package.json file for Node/JS vulnerabilities
        uses: snyk/actions/npm@master
        with:
          command: test
          args: --file=frontend/package.json --severity=high

      - name: üê≥ Snyk Base Image Analysis (Alpine/Debian/Ubuntu)
        # Scan a common base image used across your project (e.g., node:18 base for frontend)
        uses: snyk/actions/docker@master
        with:
          image: 'node:18' 
          severity: critical

  
  # ====================================================================
  # JOB 2: CI/CD PIPELINE (Build/Tag/Push/Deploy)
  # This job will only run if security_scan_pre_build succeeds.
  # ====================================================================
  ci_cd_pipeline:
    # Requires the security scan job to complete successfully
    needs: security_scan_pre_build 
    runs-on: ubuntu-latest
    
    steps:
      - name: ‚¨áÔ∏è Checkout Repository
        uses: actions/checkout@v4

      # --- UNIT TESTS STAGE ---

      - name: ‚öôÔ∏è Set up Python Environment
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: üì¶ Install Python Dependencies
        run: pip install pytest

      - name: üß™ Run Unit Tests
        working-directory: test
        run: pytest --maxfail=1 --disable-warnings -q

      # --- BUILD STAGE (using Version Control) ---

      - name: üõ†Ô∏è Setup Docker Compose
        run: docker compose version

      - name: üèóÔ∏è Build and Tag Docker Images for Nexus
        # Define the full, versioned tags as variables
        env:
          AUTH_TAG: ${{ env.NEXUS_REGISTRY }}/auth-service:${{ env.IMAGE_VERSION }}
          BACKEND_TAG: ${{ env.NEXUS_REGISTRY }}/backend:${{ env.IMAGE_VERSION }}
          FRONTEND_TAG: ${{ env.NEXUS_REGISTRY }}/frontend:${{ env.IMAGE_VERSION }}
        run: |
          cd infra
          echo "Starting Docker builds with tag: ${{ env.IMAGE_VERSION }}"
          
          # 1. Build images. They are temporarily named using the PROJECT_NAME variable.
          docker compose build \
            --build-arg IMAGE_VERSION=${{ env.IMAGE_VERSION }} \
            auth-service backend frontend 
          
          # 2. Manually tag the locally created images with the correct Nexus tag.
          docker tag ${{ env.PROJECT_NAME }}_auth-service $AUTH_TAG
          docker tag ${{ env.PROJECT_NAME }}_backend $BACKEND_TAG
          docker tag ${{ env.PROJECT_NAME }}_frontend $FRONTEND_TAG
          
          echo "All images successfully built and tagged for Nexus."

      # --- SECURITY SCAN STAGE (Post-Build Scan) ---
      
      - name: üîë Set up Snyk (for post-build scan)
        uses: snyk/actions/setup@master
        with:
          snyk-token: ${{ secrets.SNYK_TOKEN }}

      - name: üõ°Ô∏è Snyk Final Image Scan (auth-service)
        # This scans the final, layered image for deep OS/package issues
        uses: snyk/actions/docker@master
        env:
          AUTH_TAG: ${{ env.NEXUS_REGISTRY }}/auth-service:${{ env.IMAGE_VERSION }}
        with:
          image: ${{ env.AUTH_TAG }}
          severity: critical

      # --- PUSH STAGE ---

      - name: üîë Log in to Nexus Repository (via Docker CLI)
        run: |
          echo "${{ secrets.NEXUS_PASSWORD }}" | docker login ${{ env.NEXUS_REGISTRY }} \
          --username ${{ secrets.NEXUS_USERNAME }} \
          --password-stdin
      
      - name: üöÄ Push Images to Nexus (Version Control Implemented)
        env:
          AUTH_TAG: ${{ env.NEXUS_REGISTRY }}/auth-service:${{ env.IMAGE_VERSION }}
          BACKEND_TAG: ${{ env.NEXUS_REGISTRY }}/backend:${{ env.IMAGE_VERSION }}
          FRONTEND_TAG: ${{ env.NEXUS_REGISTRY }}/frontend:${{ env.IMAGE_VERSION }}
        run: |
          docker push $AUTH_TAG
          docker push $BACKEND_TAG
          docker push $FRONTEND_TAG

      # --- DEPLOYMENT STAGE ---
      
      - name: ‚òÅÔ∏è Deploy Services (Placeholder for Remote Deploy)
        run: |
          echo "Deployment to ${{ env.DEPLOY_ENV }} initiated using images tagged with version: ${{ env.IMAGE_VERSION }}"

      # --- POST: CLEANUP ---

      - name: üßπ Cleanup Docker Resources
        if: always()
        run: docker system prune -af